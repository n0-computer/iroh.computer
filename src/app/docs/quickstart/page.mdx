export const metadata = {
  title: 'Quickstart',
  description:
    'Transfer a file peer-to-peer between nodes',
};


# Quickstart

Let's dive into iroh by building a simple peer-to-peer file transfer tool in rust! {{ className: 'lead' }}


## What we'll build

At the end we should be able to transfer a file from one device by running this:

```sh
$ cargo run -- send ./file.txt
Indexing file.
File analyzed. Fetch this file by running:
cargo run -- receive blobabvojvy[...] file.txt
```

And then fetch it on any other device like so:
```sh
$ cargo run -- receive blobabvojvy[...] file.txt
Starting download.
Finished download.
Copying to destination.
Finished copying.
Shutting down.
```

In this guide we'll be omitting the import statements required to get this working.
If you're ever confused about what to import, take a look at the imports in the [complete example](https://github.com/n0-computer/iroh-blobs/blob/main/examples/transfer.rs).


## Get set up

We'll assume you've set up [rust](https://www.rust-lang.org/) and [cargo](https://doc.rust-lang.org/cargo/) on your machine.

Initialize a new project by running `cargo init file-transfer`, then `cd file-transfer` and install all the packages we're going to use: `cargo add iroh iroh-blobs tokio anyhow`.

From here on we'll be working inside the `src/main.rs` file.


## Create an `iroh::Endpoint`

To start interacting with other iroh nodes, we need to build an `iroh::Endpoint`.
This is what manages the possibly changing network underneath, maintains a connection to the closest relay, and finds ways to address devices by `NodeId`.

```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Create an endpoint, it allows creating and accepting
    // connections in the iroh p2p world
    let endpoint = Endpoint::builder().discovery_n0().bind().await?;

    // ...

    Ok(())
}
```

There we go, this is all we need to [open connections](https://docs.rs/iroh/latest/iroh/endpoint/struct.Endpoint.html#method.connect) or [accept them](https://docs.rs/iroh/latest/iroh/endpoint/struct.Endpoint.html#method.accept).

<Note>
Here, we're specifically configuring the `Endpoint`'s builder to include "number 0 discovery".
This makes it connect to DNS servers that [number 0](https://n0.computer) runs to find which relay to talk to for specific `NodeId`s.
It's a great default!
But if you want to, you can add other discovery types like [`discovery_local_network`](https://docs.rs/iroh/latest/iroh/endpoint/struct.Builder.html#method.discovery_local_network) based on mDNS, or [`discovery_dht`](https://docs.rs/iroh/latest/iroh/endpoint/struct.Builder.html#method.discovery_dht) for discovery based on the bittorrent mainline DHT.

If all of this is too much magic for your taste, it's possible for the endpoint to work entirely without any discovery services.
In that case, you'll need to make sure you're not only dialing by `NodeId`, but also help the `Endpoint` out with giving it the whole [`NodeAddr`](https://docs.rs/iroh/latest/iroh/struct.NodeAddr.html) when connecting.
</Note>


## Using an existing protocol: iroh-blobs

Instead of writing our own protocol from scratch, let's use [iroh-blobs](/proto/iroh-blobs), which already does what we want:
It loads files from your file system and provides a protocol for seekable, resumable downloads of these files.

```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Create an endpoint, it allows creating and accepting
    // connections in the iroh p2p world
    let endpoint = Endpoint::builder().discovery_n0().bind().await?;

    // We initialize an in-memory backing store for iroh-blobs
    let store = MemStore::new();
    // Then we initialize a struct that can accept blobs requests over iroh connections
    let blobs = BlobsProtocol::new(&store, endpoint.clone(), None);

    // ...

    Ok(())
}
```

<Note>
Learn more about what we mean by "protocol" on the [protocol documentation page](/docs/concepts/protocol).
</Note>

With these two lines, we've initialized iroh-blobs and gave it access to our `Endpoint`.

At this point what we want to do depends on whether we want to accept incoming iroh connections from the network or create outbound iroh connections to other nodes.
Which one we want to do depends on if the executable was called with `send` as an argument or `receive`, so let's parse these two options out from the CLI arguments and match on them:

```rust
// Grab all passed in arguments, the first one is the binary itself, so we skip it.
let args: Vec<String> = std::env::args().skip(1).collect();
// Convert to &str, so we can pattern-match easily:
let arg_refs: Vec<&str> = args.iter().map(String::as_str).collect();

match arg_refs.as_slice() {
    ["send", filename] => {
        todo!();
    }
    ["receive", ticket, filename] => {
        todo!();
    }
    _ => {
        println!("Couldn't parse command line arguments: {args:?}");
        println!("Usage:");
        println!("    # to send:");
        println!("    cargo run -- send [FILE]");
        println!("    # this will print a ticket.");
        println!();
        println!("    # to receive:");
        println!("    cargo run -- receive [TICKET] [FILE]");
    }
}
```

We're also going to print some simple help text when there's no arguments or we can't parse them.

What's left to do now is fill in the two `todo!()`s!


### Getting ready to send

If we want to make a file available over the network with iroh-blobs, we first need to hash this file.

<Note>
What does this step do?

It hashes the file using [BLAKE3](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) and remembers a so-called ["outboard"](https://github.com/oconnor663/bao?tab=readme-ov-file#outboard-mode) for that file.
This outboard contains information about hashes of parts of this file.
All of this enables some extra features with iroh-blobs like automatically verifying the integrity of the file *while it's streaming*, verified range downloads and download resumption.
</Note>

```rust
let filename: PathBuf = filename.parse()?;
let abs_path = std::path::absolute(&filename)?;

println!("Hashing file.");

// When we import a blob, we get back a "tag" that refers to said blob in the store
// and allows us to control when/if it gets garbage-collected
let tag = store.blobs().add_path(abs_path).await?;
```

<Note>
For other use cases, there are other ways of importing blobs into iroh-blobs, you're not restricted to pulling them from the file system!
You can see other options available, such as [`add_slice`](https://docs.rs/iroh-blobs/latest/iroh_blobs/api/blobs/struct.Blobs.html#method.add_slice).
Make sure to also check out the options you can pass and their documentation for some interesting tidbits on performance.
</Note>

The return value `tag` contains the final piece of information such that another node can fetch a blob from us.

We'll use a `BlobTicket` to put the file's BLAKE3 hash and our endpoint's `NodeId` into a single copy-able string:

```rust
let node_id = endpoint.node_id();
let ticket = BlobTicket::new(node_id.into(), tag.hash, tag.format);

println!("File hashed. Fetch this file by running:");
println!(
    "cargo run -- receive {ticket} {}",
    filename.display()
);
```

Now we've imported the file and produced instructions for how to fetch it, but we're actually not yet actively listening for incoming connections yet! (iroh-blobs won't do so unless you specifically tell it to do that.)

For that we'll use iroh's `Router`.
Similar to routers in webserver libraries, it runs a loop accepting incoming connections and routes them to the specific handler.
However, instead of handlers being organized by HTTP paths, it routes based on "ALPNs".
Read more about ALPNs and the router on the [protocol](/docs/concepts/protocol#alpns) and [router](/docs/concepts/router) documentation pages.

In our case, we only need a single protocol, but constructing a router also takes care of running the accept loop, so that makes our life easier:

```rs
// For sending files we build a router that accepts blobs connections & routes them
// to the blobs protocol.
let router = Router::builder(endpoint)
    .accept(iroh_blobs::ALPN, blobs)
    .spawn();

tokio::signal::ctrl_c().await?;

// Gracefully shut down the node
println!("Shutting down.");
router.shutdown().await?;
```

And as you can see, as a final step we wait for the user to stop the file providing side by hitting `Ctrl+C` in the console and once they do so, we shut down the router gracefully.


### Connecting to the other side to receive

On the connection side, we got the `ticket` and the `path` from the CLI arguments and we can parse them into their `struct` versions.

With them parsed
- we first construct a `Downloader` (that can help us coordinate multiple downloads from multiple peers if we'd want to)
- and then call `.download` with the information contained in the ticket and wait for the download to finish:

<Note>
Reusing the same downloader across multiple downloads can be more efficient, e.g. by reusing existing connections.
In this example we don't see this, but it might come in handy for your use case.
</Note>

```rust
let filename: PathBuf = filename.parse()?;
let abs_path = std::path::absolute(filename)?;
let ticket: BlobTicket = ticket.parse()?;

// For receiving files, we create a "downloader" that allows us to fetch files
// from other nodes via iroh connections
let downloader = store.downloader(&endpoint);

println!("Starting download.");

downloader
    .download(ticket.hash(), Some(ticket.node_addr().node_id))
    .await?;

println!("Finished download.");
```

<Note>
The return value of `.download()` is [`DownloadProgress`](https://docs.rs/iroh-blobs/latest/iroh_blobs/api/downloader/struct.DownloadProgress.html).
You can either `.await` it to wait for the download to finish, or you can stream out progress events instead, e.g. if you wanted to use this for showing a nice progress bar!
</Note>

As a final step, we'll export the file we just downloaded into our in-memory blobs database to the desired file path:

```rust
println!("Copying to destination.");

store.blobs().export(ticket.hash(), abs_path).await?;

println!("Finished copying.");
```

<Note>
This first downloads the file completely into memory, then copies it from memory to file in a second step.

There's ways to make this work without having to store the whole file in memory!
This would involve setting up an `FsStore` instead of a `MemStore` and using `.export_with_opts` with `ExportMode::TryReference`.
Something similar can be done on the sending side!
We'll leave these changes as an exercise to the reader 😉
</Note>

Before we leave, we'll gracefully shut down our endpoint in the receive branch, too:

```rs
// Gracefully shut down the node
println!("Shutting down.");
endpoint.close().await;
```


## That's it!

You've now successfully built a small tool for peer-to-peer file transfers! 🎉

The full example with the very latest version of iroh and iroh-blobs can be [viewed on github](https://github.com/n0-computer/iroh-blobs/blob/main/examples/transfer.rs).

If you're hungry for more, check out
- the [iroh rust documentation](https://docs.rs/iroh),
- [other examples](/docs/examples), or
- other available [protocols](/proto).
